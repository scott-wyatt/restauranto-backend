(function (root, factory) {
    const PubSub = {};
    root.PubSub = PubSub;
    factory(PubSub);
    if (typeof exports === 'object') {
        if (module !== undefined && module.exports) {
            exports = module.exports = PubSub;
        }
        exports.PubSub = PubSub;
        module.exports = exports = PubSub;
    }
}(this, function (PubSub) {
    'use strict';
    let messages = {}, lastUid = -1;
    function hasKeys(obj) {
        let key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                return true;
            }
        }
        return false;
    }
    function throwException(ex) {
        return function reThrowException() {
            throw ex;
        };
    }
    function callSubscriberWithDelayedExceptions(subscriber, message, data, options) {
        try {
            subscriber(message, data, options);
        }
        catch (ex) {
            setTimeout(throwException(ex), 0);
        }
    }
    function callSubscriberWithImmediateExceptions(subscriber, message, data, options) {
        subscriber(message, data, options);
    }
    function deliverMessage(originalMessage, matchedMessage, data, options, immediateExceptions) {
        let subscribers = messages[matchedMessage], callSubscriber = immediateExceptions ? callSubscriberWithImmediateExceptions : callSubscriberWithDelayedExceptions, s;
        if (!messages.hasOwnProperty(matchedMessage)) {
            return;
        }
        for (s in subscribers) {
            if (subscribers.hasOwnProperty(s)) {
                callSubscriber(subscribers[s], originalMessage, data, options);
            }
        }
    }
    function createDeliveryFunction(message, data, options, immediateExceptions) {
        return function deliverNamespaced() {
            let topic = String(message), position = topic.lastIndexOf('.');
            deliverMessage(message, message, data, options, immediateExceptions);
            while (position !== -1) {
                topic = topic.substr(0, position);
                position = topic.lastIndexOf('.');
                deliverMessage(message, topic, data, options, immediateExceptions);
            }
        };
    }
    function messageHasSubscribers(message) {
        let topic = String(message), found = Boolean(messages.hasOwnProperty(topic) && hasKeys(messages[topic])), position = topic.lastIndexOf('.');
        while (!found && position !== -1) {
            topic = topic.substr(0, position);
            position = topic.lastIndexOf('.');
            found = Boolean(messages.hasOwnProperty(topic) && hasKeys(messages[topic]));
        }
        return found;
    }
    function publish(message, data, options, sync, immediateExceptions) {
        let deliver = createDeliveryFunction(message, data, options, immediateExceptions), hasSubscribers = messageHasSubscribers(message);
        if (!hasSubscribers) {
            return false;
        }
        if (sync === true) {
            deliver();
        }
        else {
            setTimeout(deliver, 0);
        }
        return true;
    }
    PubSub.publish = function (message, data, options) {
        options = options || {};
        return publish(message, data, options, false, PubSub.immediateExceptions);
    };
    PubSub.publishSync = function (message, data, options) {
        options = options || {};
        return publish(message, data, options, true, PubSub.immediateExceptions);
    };
    PubSub.subscribe = function (message, func) {
        if (typeof func !== 'function') {
            return false;
        }
        if (!messages.hasOwnProperty(message)) {
            messages[message] = {};
        }
        const token = 'uid_' + String(++lastUid);
        messages[message][token] = func;
        return token;
    };
    PubSub.clearAllSubscriptions = function clearAllSubscriptions() {
        messages = {};
    };
    PubSub.getMessages = function getMessages() {
        return messages;
    };
    PubSub.clearSubscriptions = function clearSubscriptions(topic) {
        for (const m in messages) {
            if (messages.hasOwnProperty(m) && m.indexOf(topic) === 0) {
                delete messages[m];
            }
        }
    };
    PubSub.unsubscribe = function (value) {
        let descendantTopicExists = function (topic) {
            let m;
            for (m in messages) {
                if (messages.hasOwnProperty(m) && m.indexOf(topic) === 0) {
                    return true;
                }
            }
            return false;
        }, isTopic = typeof value === 'string' && (messages.hasOwnProperty(value) || descendantTopicExists(value)), isToken = !isTopic && typeof value === 'string', isFunction = typeof value === 'function', result = false, m, message, t;
        if (isTopic) {
            PubSub.clearSubscriptions(value);
            return;
        }
        for (m in messages) {
            if (messages.hasOwnProperty(m)) {
                message = messages[m];
                if (isToken && message[value]) {
                    delete message[value];
                    result = value;
                    break;
                }
                if (isFunction) {
                    for (t in message) {
                        if (message.hasOwnProperty(t) && message[t] === value) {
                            delete message[t];
                            result = true;
                        }
                    }
                }
            }
        }
        return result;
    };
}));
