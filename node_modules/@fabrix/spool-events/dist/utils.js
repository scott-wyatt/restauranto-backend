"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
exports.Utils = {
    getWorkerProfile: (profileName, typeConfig) => {
        if (!profileName || !typeConfig.profiles[profileName]) {
            return [];
        }
        return typeConfig.profiles[profileName];
    },
    configureExchangesAndQueues: (profile, taskerConfig) => {
        const exchangeName = taskerConfig.exchange || 'tasker-work-x';
        const workQueueName = taskerConfig.work_queue_name || 'tasker-work-q';
        const interruptQueueName = taskerConfig.interrupt_queue_name || 'tasker-interrupt-q';
        taskerConfig.exchangeName = exchangeName;
        taskerConfig.exchanges = [{
                name: exchangeName,
                type: 'topic',
                autoDelete: false
            }];
        taskerConfig.queues = [{
                name: workQueueName,
                autoDelete: false,
                subscribe: true
            }, {
                name: interruptQueueName,
                autoDelete: false,
                subscribe: true
            }];
        taskerConfig.bindings = [{
                exchange: exchangeName,
                target: workQueueName,
                keys: profile
            }, {
                exchange: exchangeName,
                target: interruptQueueName,
                keys: profile.map(task => task + '.interrupt')
            }];
        return taskerConfig;
    },
    registerTasks: (profile, app, rabbit) => {
        profile.forEach(taskName => {
            app.tasker.active_tasks.set(taskName, []);
            exports.Utils.registerRun(taskName, app, rabbit);
            exports.Utils.registerInterrupt(taskName, app, rabbit);
        });
    },
    clearHandler: (activeTasks, task) => {
        lodash_1.remove(activeTasks, activeTask => {
            return task.id = activeTask.id;
        });
    },
    registerInterrupt: (taskName, app, rabbit) => {
        rabbit.handle(`${taskName}.interrupt`, message => {
            const taskId = message.body.taskId;
            const activeTasks = app.tasker.active_tasks.get(taskName) || [];
            const task = lodash_1.find(activeTasks, activeTask => {
                return activeTask.id = taskId;
            });
            if (!task) {
                app.log.info('Failed to interrupt task, no active handler found for task ' +
                    taskName + ' and id ' + taskId);
                return message.reject();
            }
            return task.interrupt(message);
        });
    },
    registerRun: (taskName, app, rabbit) => {
        const taskerClient = app.tasker;
        rabbit.handle(taskName, message => {
            if (!app.api.tasks[taskName]) {
                app.log.error(`No task defined for task name: ${taskName}. Message body was:` +
                    `${JSON.stringify(message.body)}`);
                return message.reject();
            }
            const task = new app.api.tasks[taskName](app, message);
            taskerClient.active_tasks.get(taskName).push(task);
            return Promise.resolve()
                .then(() => {
                return task.run();
            })
                .catch(err => {
                app.log.info(`Error in task.run() for task ${taskName}`, err);
                return task.reject();
            })
                .then(() => {
                return task.finalize()
                    .then(() => {
                    return exports.Utils.clearHandler(taskerClient.active_tasks.get(taskName), task);
                })
                    .catch(() => {
                    return exports.Utils.clearHandler(taskerClient.active_tasks.get(taskName), task);
                });
            });
        });
    }
};
