"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@fabrix/fabrix/dist/common");
const lodash_1 = require("lodash");
const _1 = require("../../");
const enums_1 = require("../../enums");
class EventsService extends common_1.FabrixService {
    getModel(modelName) {
        return this.app.models[modelName] || this.app.spools.sequelize.models[modelName];
    }
    count(modelName, criteria, options) {
        const Model = this.getModel(modelName);
        const modelOptions = lodash_1.defaultsDeep({}, options, this.app.config.get('tapestries.models.options'));
        if (!Model) {
            return Promise.reject(new _1.Errors.ModelError('E_NOT_FOUND', `${modelName} can't be found`, []));
        }
        return Model.count(criteria, modelOptions);
    }
    publish(type, data, options = {}) {
        return new Promise((resolve, reject) => {
            if (this.app.config.get('events.auto_save') || options.save) {
                this.resolveEvent(data, { transaction: options.transaction || null })
                    .then(resEvent => {
                    const event = this.app.pubSub.publish(type, resEvent, options);
                    return resolve(event);
                })
                    .catch(err => {
                    this.app.log.debug(err);
                    const event = this.app.pubSub.publish(type, data, options);
                    return resolve(event);
                });
            }
            else {
                const event = this.app.pubSub.publish(type, data, options);
                return resolve(event);
            }
        });
    }
    subscribe(name, type, func) {
        const self = this;
        const tryCatch = function (type, data, options) {
            try {
                func(type, data, options);
            }
            catch (err) {
                const event = {
                    object: type.split('.')[0],
                    type: type,
                    data: data
                };
                return self.subscriptionFailure(event, name, err.toString(), options);
            }
        };
        return this.app.pubSub.subscribe(type, tryCatch);
    }
    subscriptionFailure(event, name, err, options = {}) {
        let resEvent, resSubscriber;
        return this.resolveEvent(event, { transaction: options.transaction || null })
            .then(foundEvent => {
            if (!foundEvent) {
            }
            resEvent = foundEvent;
            return this.resolveEventSubscriber({
                event_id: resEvent.id,
                name: name,
                response: err
            }, {
                transaction: options.transaction || null
            });
        })
            .then(eventSubscriber => {
            resSubscriber = eventSubscriber;
            return resEvent.hasSubscriber(resSubscriber.id, { transaction: options.transaction || null });
        })
            .then((result) => {
            if (result) {
                resSubscriber.last_attempt = new Date();
                resSubscriber.status = enums_1.EVENT_SUBSCRIBER_STATUS.PENDING;
                return resSubscriber.increment('attempts');
            }
            else {
                return resEvent.addSubscriber(resSubscriber, { transaction: options.transaction || null });
            }
        })
            .then(eventSubcriber => {
            return resSubscriber.reload();
        });
    }
    unsubscribe(token) {
        return this.app.pubSub.unsubscribe(token);
    }
    resolveEvent(event, options = {}) {
        const Event = this.app.models['Event'];
        if (event instanceof Event.instance) {
            return Promise.resolve(event);
        }
        return Event.datastore.transaction(t => {
            if (event.id) {
                return Event.findById(event.id, {
                    include: [
                        {
                            model: this.app.models['EventItem'].instance,
                            as: 'objects'
                        }
                    ],
                    transaction: options.transaction || t
                });
            }
            else if (event.request && event.request !== '') {
                return Event.findOne({
                    where: {
                        request: event.request
                    },
                    include: [
                        {
                            model: this.app.models['EventItem'].instance,
                            as: 'objects'
                        }
                    ],
                    transaction: options.transaction || t
                });
            }
            else if (lodash_1.isNumber(event)) {
                return Event.findById(event, {
                    include: [
                        {
                            model: this.app.models['EventItem'].instance,
                            as: 'objects'
                        }
                    ],
                    transaction: options.transaction || t
                });
            }
            else if (lodash_1.isString(event)) {
                return Event.findOne({
                    where: {
                        request: event
                    },
                    include: [
                        {
                            model: this.app.models['EventItem'].instance,
                            as: 'objects'
                        }
                    ],
                    transaction: options.transaction || t
                });
            }
            else {
                const items = event.objects || [];
                event.objects = items.map(item => {
                    const model = Object.keys(item)[0];
                    if (item.object_id && item.object) {
                        return item;
                    }
                    else {
                        return {
                            object_id: item[model],
                            object: model
                        };
                    }
                });
                return Event.create(event, {
                    include: [
                        {
                            model: this.app.models['EventItem'].instance,
                            as: 'objects'
                        }
                    ],
                    transaction: options.transaction || t
                });
            }
        });
    }
    resolveEventSubscriber(eventSubscriber, options = {}) {
        const EventSubscriber = this.app.models['EventSubscriber'];
        if (eventSubscriber instanceof EventSubscriber.instance) {
            return Promise.resolve(eventSubscriber);
        }
        return EventSubscriber.datastore.transaction(t => {
            if (eventSubscriber.id) {
                return EventSubscriber.findById(eventSubscriber.id, {
                    transaction: options.transaction || t
                });
            }
            else if (eventSubscriber.event_id && eventSubscriber.name) {
                return EventSubscriber.findOne({
                    where: {
                        event_id: eventSubscriber.event_id,
                        name: eventSubscriber.name
                    },
                    transaction: options.transaction || t
                })
                    .then(resSubscriber => {
                    if (!resSubscriber) {
                        return EventSubscriber.create(eventSubscriber, { transaction: options.transaction || t });
                    }
                    return resSubscriber;
                });
            }
            else {
                const err = new Error('Event Subscriber not able to resolve');
                return Promise.reject(err);
            }
        });
    }
    destroyEvent(event, options = {}) {
        options = options || {};
        const Event = this.app.models['Event'];
        return Event.destroy({
            where: {
                id: event.id
            },
            transaction: options.transaction || null
        });
    }
}
exports.EventsService = EventsService;
