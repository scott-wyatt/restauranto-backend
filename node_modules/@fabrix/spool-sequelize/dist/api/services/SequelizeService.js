"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@fabrix/fabrix/dist/common");
const lodash_1 = require("lodash");
class SequelizeService extends common_1.FabrixService {
    mergeOptionDefaults(...options) {
        let wheres = {};
        let limits = null;
        let offsets = null;
        let includes = [];
        let orders = [];
        let newOptions;
        for (const option of options) {
            if (!(option instanceof Object)) {
                throw new Error(`Option must be an object, type of option was ${typeof option}`);
            }
            includes = this.mergeOptionIncludes(includes, option.include);
            orders = this.mergeOptionOrders(orders, option.order);
            wheres = this.mergeOptionWheres(wheres, option.where);
            limits = this.mergeOptionLimits(limits, option.limit);
            offsets = this.mergeOptionOffsets(offsets, option.offset);
        }
        newOptions = {
            include: includes,
            order: orders,
            where: wheres,
            limit: limits,
            offset: offsets
        };
        for (const option of options.reverse()) {
            newOptions = lodash_1.defaults({}, newOptions, option);
        }
        return lodash_1.omitBy(newOptions, lodash_1.isNil);
    }
    mergeOptionIncludes(originals = [], overrides = []) {
        const includes = originals;
        if (!lodash_1.isArray(originals) || !lodash_1.isArray(overrides)) {
            throw new Error('include must be an array');
        }
        overrides.map(include => {
            const inIncludes = includes.findIndex(i => i.model === include.model);
            if (inIncludes !== -1 && includes[inIncludes]['as'] === include.as) {
                includes[inIncludes] = include;
            }
            else {
                includes.push(include);
            }
        });
        return includes;
    }
    mergeOptionOrders(originals = [], overrides = []) {
        if (lodash_1.isString(originals)) {
            originals = [originals.trim().split(' ')];
        }
        let order = originals;
        if (lodash_1.isString(overrides)) {
            order.push(overrides.trim().split(' '));
        }
        else if (lodash_1.isArray(overrides)) {
            order = order.concat(overrides);
        }
        else if (lodash_1.isObject(overrides)) {
            order.push([overrides]);
        }
        return order;
    }
    mergeOptionWheres(originals = {}, overrides = {}) {
        const where = lodash_1.merge(originals, overrides);
        return where;
    }
    mergeOptionOffsets(originals, overrides) {
        let offset = originals;
        if (overrides) {
            offset = overrides;
        }
        return offset;
    }
    mergeOptionLimits(originals, overrides) {
        let limit = originals;
        if (overrides) {
            limit = overrides;
        }
        return limit;
    }
}
exports.SequelizeService = SequelizeService;
