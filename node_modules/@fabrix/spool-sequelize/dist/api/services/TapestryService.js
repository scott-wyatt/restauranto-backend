"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@fabrix/fabrix/dist/common");
const lodash_1 = require("lodash");
const errors_1 = require("../../errors");
const manageError = err => {
    if (err.name === 'SequelizeValidationError') {
        return Promise.reject(new errors_1.ModelError('E_VALIDATION', err.message, err.errors));
    }
    return Promise.reject(err);
};
class TapestryService extends common_1.FabrixService {
    _getModel(modelName) {
        const model = this.app.models[modelName]
            || this.app.spools['sequelize'].models[modelName]
            || lodash_1.find(this.app.models, { tableName: modelName })
            || lodash_1.find(this.app.spools['sequelize'].models, { tableName: modelName });
        if (model && model.resolver && model.resolver.sequelizeModel) {
            return model.resolver.sequelizeModel;
        }
        else if (model && model.sequelizeModel) {
            return model.sequelizeModel;
        }
        else {
            return model;
        }
    }
    create(modelName, values, options) {
        const Model = this._getModel(modelName);
        const modelOptions = lodash_1.defaultsDeep({}, options, this.app.config.get('tapestries.models.options'));
        if (!Model) {
            return Promise.reject(new errors_1.ModelError('E_NOT_FOUND', `${modelName} can't be found`));
        }
        if (modelOptions.populate) {
            modelOptions.include = this._createIncludeField(Model, modelOptions.populate);
        }
        return Model.create(values, modelOptions).catch(manageError);
    }
    _createIncludeField(model, populate) {
        if (populate === true || populate === 'all') {
            return { all: true };
        }
        if (lodash_1.isPlainObject(populate) || lodash_1.isArray(populate)) {
            return populate;
        }
        const fields = populate.split(',');
        const includes = [];
        fields.forEach((value, key) => {
            includes.push(model.associations[value]);
        });
        return includes;
    }
    find(modelName, criteria, options) {
        const Model = this._getModel(modelName);
        const modelOptions = lodash_1.defaultsDeep({}, options, this.app.config.get('tapestries.models.options'));
        let query;
        if (!Model) {
            return Promise.reject(new errors_1.ModelError('E_NOT_FOUND', `${modelName} can't be found`));
        }
        if (modelOptions.populate) {
            modelOptions.include = this._createIncludeField(Model, modelOptions.populate);
        }
        delete modelOptions.populate;
        if (!lodash_1.isPlainObject(criteria) || modelOptions.findOne === true) {
            if (modelOptions.findOne === true) {
                if (!criteria.where) {
                    criteria = { where: criteria };
                }
                query = Model.find(lodash_1.defaults(criteria, modelOptions));
            }
            else {
                query = Model.find(lodash_1.defaults({
                    where: {
                        [Model.primaryKeyAttribute]: criteria
                    }
                }, modelOptions));
            }
        }
        else {
            if (!criteria.where) {
                criteria = { where: criteria };
            }
            if (modelOptions.sort) {
                criteria.order = modelOptions.sort;
                delete modelOptions.sort;
            }
            query = Model.findAll(lodash_1.defaults(criteria, modelOptions));
        }
        return query.catch(manageError);
    }
    update(modelName, criteria, values, options = {}) {
        const Model = this._getModel(modelName);
        if (!Model) {
            return Promise.reject(new errors_1.ModelError('E_NOT_FOUND', `${modelName} can't be found`));
        }
        let query;
        if (!criteria) {
            criteria = {};
        }
        if (lodash_1.isArray(options.populate) || lodash_1.isPlainObject(options.populate)) {
            options.include = options.populate;
            delete options.populate;
        }
        if (lodash_1.isPlainObject(criteria)) {
            if (!criteria.where) {
                criteria = { where: criteria };
            }
            query = Model.update(values, lodash_1.extend(criteria, options));
        }
        else {
            criteria = {
                where: {
                    [Model.primaryKeyAttribute]: criteria
                }
            };
            query = Model.update(values, lodash_1.extend(criteria, options));
        }
        return query.catch(manageError);
    }
    destroy(modelName, criteria, options = {}) {
        const Model = this._getModel(modelName);
        let query;
        if (!Model) {
            return Promise.reject(new errors_1.ModelError('E_NOT_FOUND', `${modelName} can't be found`));
        }
        if (lodash_1.isArray(options.populate) || lodash_1.isPlainObject(options.populate)) {
            options.include = options.populate;
            delete options.populate;
        }
        if (lodash_1.isPlainObject(criteria)) {
            if (!criteria.where) {
                criteria = { where: criteria };
            }
            if (lodash_1.isArray(options.populate) || lodash_1.isPlainObject(options.populate)) {
                criteria.include = options.populate;
                delete options.populate;
            }
            query = Model.destroy(lodash_1.extend(criteria, options));
        }
        else {
            criteria = {
                where: {
                    [Model.primaryKeyAttribute]: criteria
                }
            };
            query = Model.destroy(lodash_1.extend(criteria, options)).then(results => results[0]);
        }
        return query.catch(manageError);
    }
    createAssociation(parentModelName, parentId, childAttributeName, values, options) {
        const parentModel = this._getModel(parentModelName);
        if (!parentModel) {
            return Promise.reject(new errors_1.ModelError('E_NOT_FOUND', `${parentModelName} can't be found`));
        }
        const association = parentModel.associations[childAttributeName];
        if (!association) {
            return Promise.reject(new errors_1.ModelError('E_NOT_FOUND', `${parentModelName}'s association ${childAttributeName} can't be found`));
        }
        const childModelName = association.target.name;
        const childModel = this._getModel(childModelName);
        if (!options) {
            options = {};
        }
        if (association.foreignKeyField || (association.sourceKey && !association.targetKey)) {
            values[association.foreignKeyField || association.foreignKey] = parentId;
        }
        return parentModel.sequelize.transaction(t => {
            options.transaction = t;
            return this.create(childModelName, values, options).then(child => {
                let promise = Promise.resolve();
                if (association.throughModel) {
                    promise = promise.then(association.throughModel.create({
                        [association.identifierField]: parentId,
                        [association.foreignIdentifierField]: child[childModel.primaryKeyAttribute]
                    }, options));
                }
                if (!association.foreignKeyField) {
                    promise = promise.then(this.update(parentModelName, parentId, {
                        [association.identifierField]: child[childModel.primaryKeyAttribute]
                    }, options).then(() => child));
                }
                promise = promise.then(() => child);
                return promise;
            });
        });
    }
    findAssociation(parentModelName, parentId, childAttributeName, criteria, options) {
        const parentModel = this._getModel(parentModelName);
        if (!parentModel) {
            return Promise.reject(new errors_1.ModelError('E_NOT_FOUND', `${parentModelName} can't be found`));
        }
        const association = parentModel.associations[childAttributeName];
        if (!association) {
            return Promise.reject(new errors_1.ModelError('E_NOT_FOUND', `${parentModelName}'s association ${childAttributeName} can't be found`));
        }
        const childModelName = association.target.name;
        const childModel = this._getModel(childModelName);
        if (!childModel) {
            return Promise.reject(new errors_1.ModelError('E_NOT_FOUND', `${childModelName} can't be found`));
        }
        if (association.foreignKeyField || (association.sourceKey && !association.targetKey)) {
            if (!criteria) {
                criteria = {};
            }
            else if (!lodash_1.isPlainObject(criteria)) {
                criteria = {
                    [childModel.primaryKeyAttribute]: criteria
                };
            }
            criteria[association.foreignKeyField || association.foreignKey] = parentId;
            if (!options) {
                options = {};
            }
            return this.find(childModelName, criteria, options);
        }
        else if (association.throughModel) {
            return this._getThroughModelAssociation(association, parentId)
                .then(ids => childModel.findAll(lodash_1.extend({
                where: {
                    $and: [
                        criteria || {},
                        {
                            [childModel.primaryKeyAttribute]: {
                                $in: ids
                            }
                        }
                    ]
                }
            }, options)))
                .catch(manageError);
        }
        else {
            return this.find(parentModelName, parentId, options)
                .then(parent => this.find(childModelName, parent[association.identifierField], options));
        }
    }
    updateAssociation(parentModelName, parentId, childAttributeName, criteria, values, options) {
        const parentModel = this._getModel(parentModelName);
        if (!parentModel) {
            return Promise.reject(new errors_1.ModelError('E_NOT_FOUND', `${parentModelName} can't be found`));
        }
        const association = parentModel.associations[childAttributeName];
        if (!association) {
            return Promise.reject(new errors_1.ModelError('E_NOT_FOUND', `${parentModelName}'s association ${childAttributeName} can't be found`));
        }
        const childModelName = association.target.name;
        const childModel = this._getModel(childModelName);
        if (!childModel) {
            return Promise.reject(new errors_1.ModelError('E_NOT_FOUND', `${childModelName} can't be found`));
        }
        if (association.foreignKeyField || (association.sourceKey && !association.targetKey)) {
            if (!options) {
                options = {};
            }
            if (!criteria) {
                criteria = {};
            }
            else if (!lodash_1.isPlainObject(criteria)) {
                criteria = {
                    [childModel.primaryKeyAttribute]: criteria
                };
                options.findOne = true;
            }
            criteria[association.foreignKeyField || association.foreignKey] = parentId;
            return this.update(childModelName, criteria, values, options);
        }
        else if (association.throughModel) {
            return this._getThroughModelAssociation(association, parentId)
                .then(ids => childModel.update(values, lodash_1.extend({
                where: {
                    $and: [
                        criteria || {},
                        {
                            [childModel.primaryKeyAttribute]: {
                                $in: ids
                            }
                        }
                    ]
                }
            }, options)))
                .catch(manageError);
        }
        else {
            return this.find(parentModelName, parentId, options)
                .then(parent => this.update(childModelName, parent[association.identifierField], values, options));
        }
    }
    _getThroughModelAssociation(association, parentId) {
        return association.throughModel.findAll({
            where: {
                [association.identifierField]: parentId
            },
            attributes: [association.foreignIdentifierField]
        })
            .then(throughTables => throughTables.map(throughTable => throughTable[association.foreignIdentifierField]));
    }
    destroyAssociation(parentModelName, parentId, childAttributeName, criteria, options) {
        return this
            .findAssociation(parentModelName, parentId, childAttributeName, criteria, options)
            .then(records => {
            if (!(records instanceof Array)) {
                records = [records];
            }
            return Promise.all(records.map(record => {
                return record.destroy();
            }));
        })
            .catch(manageError);
    }
}
exports.TapestryService = TapestryService;
