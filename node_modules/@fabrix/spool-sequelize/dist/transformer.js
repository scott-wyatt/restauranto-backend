"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Sequelize = require("sequelize");
const lodash_1 = require("lodash");
const SequelizeResolver_1 = require("./SequelizeResolver");
exports.Transformer = {
    BreakException: {},
    reservedMethods: [
        '_app',
        '_datastore',
        'app',
        'api',
        'log',
        '__',
        'constructor',
        'undefined',
        'methods',
        'config',
        'schema',
        'services',
        'models',
        'connect'
    ],
    dataTypes: {
        '^(STRING|string)': 'STRING',
        '^(STRING|string)\((\w*)\)': 'STRING($2)',
        '(STRING.BINARY)': 'STRING.BINARY',
        '^(TEXT|text)': 'TEXT',
        '^(TEXT|text)\((\w*)\)': 'TEXT($2)',
        '^(INTEGER|integer|int)': 'INTEGER',
        '^(BIGINT)': 'BIGINT',
        '^(BIGINT)\((\d*)\)': 'BIGINT($2)',
        '^(FLOAT)': 'FLOAT',
        '^(FLOAT)\((\d*)\)': 'FLOAT($2)',
        '^(FLOAT)\((\d*),\s(\d*)\)': 'FLOAT($2, $3)',
        '^(REAL)': 'REAL',
        '^(REAL)\((\d*)\)': 'REAL($2)',
        '^(REAL)\((\d*),\s(\d*)\)': 'REAL($2, $3)',
        '^(DOUBLE)': 'DOUBLE',
        '^(DOUBLE)\((\d*)\)': 'DOUBLE($2)',
        '^(DOUBLE)\((\d*),\s(\d*)\)': 'DOUBLE($2, $3)',
        '^(DECIMAL)': 'DECIMAL',
        '^(DECIMAL)\((\d*),\s(\d*)\)': 'DECIMAL($2, $3)',
        '^(DATE|date)': 'DATE',
        '^(DATE)\((\d*)\)': 'DATE($2)',
        '^(DATEONLY)': 'DATEONLY',
        '^(BOOLEAN)': 'BOOLEAN',
        '^(ENUM)': 'ENUM',
        '^(ENUM)\((.*)?\)': 'ENUM($2)',
        '^(ARRAY)\((\w*)\)': 'ARRAY($2)',
        '^(JSON|json)': 'JSON',
        '^(JSONB|jsonb)': 'JSONB',
        '^(BLOB)': 'BLOB',
        '^(BLOB)\((\w*)\)': 'BLOB($2)',
        '^(UUID)': 'UUID',
        '^(CIDR)': 'CIDR',
        '^(INET)': 'INET',
        '^(MACADDR)': 'MACADDR',
        '^(RANGE)\((\w*)\)': 'RANGE($2)',
        '^(GEOMETRY)': 'GEOMETRY',
        '^(GEOMETRY)\((\w*)\)': 'GEOMETRY($2)',
        '^(GEOMETRY)\((\w*),\s(\d*)\)': 'GEOMETRY($2, $3)'
    },
    getClassMethods(obj) {
        const props = [];
        const objectRoot = new Object();
        while (!obj.isPrototypeOf(objectRoot)) {
            Object.getOwnPropertyNames(obj).forEach(prop => {
                if (props.indexOf(prop) === -1
                    && !exports.Transformer.reservedMethods.some(p => p === prop)
                    && typeof obj[prop] === 'function') {
                    props.push(prop);
                }
            });
            obj = Object.getPrototypeOf(obj);
        }
        return props;
    },
    getModelOptions: (app, model) => {
        const config = model.constructor.config(app, Sequelize);
        if (!config.options) {
            config.options = {};
        }
        if (!config.options.tableName) {
            config.options.tableName = model.name.toLowerCase();
        }
        return config.options;
    },
    getModelSchema: (app, model) => {
        const schema = exports.Transformer.transformSchema(model.constructor.schema(app, Sequelize));
        return schema;
    },
    replaceDataType: (dataType) => {
        let transformed;
        try {
            Object.keys(exports.Transformer.dataTypes).forEach(type => {
                const exp = new RegExp(type);
                if (exp.test(dataType)) {
                    transformed = Sequelize[dataType.replace(exp, exports.Transformer.dataTypes[type])];
                    throw exports.Transformer.BreakException;
                }
            });
        }
        catch (e) {
            if (e !== exports.Transformer.BreakException) {
                throw e;
            }
        }
        return transformed;
    },
    transformSchema: (schema) => {
        const transformed = {};
        Object.keys(schema).forEach(s => {
            if (typeof schema[s] === 'string') {
                transformed[s] = exports.Transformer.replaceDataType(schema[s]);
            }
            else {
                transformed[s] = schema[s];
            }
        });
        return transformed;
    },
    getModelPrototypes: (model) => {
        return Object.getPrototypeOf(model);
    },
    getModelMethods: (model, prototypes) => {
        const methods = {};
        const methodNames = model.methods.filter(m => Object.keys(prototypes).indexOf(m) === -1);
        methodNames.forEach(m => methods[m] = model[m]);
        return methods;
    },
    defineModel: (app, model, connections) => {
        const modelName = model.constructor.name;
        const modelConfig = model.config;
        const store = modelConfig.store || app.config.get('models.defaultStore');
        const connection = connections[store];
        const migrate = modelConfig.migrate || app.config.get('models.migrate') || connection.migrate;
        const options = exports.Transformer.getModelOptions(app, model);
        const schema = exports.Transformer.getModelSchema(app, model);
        if (!model.resolver || !model.resolver.connect) {
            throw new Error(`${modelName} was set to use Sequelize but the resolver is missing "connect"`);
        }
        if (!(model.resolver instanceof SequelizeResolver_1.SequelizeResolver)) {
            throw new Error(`${modelName} is not a Sequelize Resolver`);
        }
        model.store = store;
        model.migrate = migrate;
        model.resolver.connection = connection;
        model.resolver.connect(modelName, schema, options);
        return model;
    },
    createConnectionsFromConfig(app, config) {
        const logger = function (str) {
            app.log.debug(str);
        };
        if (config.uri) {
            return new Sequelize(config.uri, Object.assign({}, { logging: logger }, config));
        }
        else {
            return new Sequelize(config.database, config.username || process.env.POSTGRES_USER, config.password || process.env.POSTGRES_PASSWORD, Object.assign({}, { logging: logger }, config));
        }
    },
    pickStores(stores) {
        return lodash_1.pickBy(stores, (_store, name) => {
            return ((_store.dialect && lodash_1.isString(_store.dialect) && _store.orm === 'sequelize')
                || lodash_1.startsWith(_store.uri, 'mysql://')
                || lodash_1.startsWith(_store.uri, 'mysql://')
                || lodash_1.startsWith(_store.uri, 'postgresql://')
                || lodash_1.startsWith(_store.uri, 'sqlite://'));
        });
    },
    pickModels(app, connections) {
        const stores = Object.keys(connections);
        return lodash_1.pickBy(app.models, (_model, name) => {
            const modelConfig = _model.config;
            const store = modelConfig.store || app.config.get('models.defaultStore');
            return (stores.indexOf(store) > -1);
        });
    },
    getConnections(app) {
        const stores = exports.Transformer.pickStores(app.config.get('stores'));
        const sequelize = {};
        Object.keys(stores).forEach(key => {
            sequelize[key] = exports.Transformer.createConnectionsFromConfig(app, stores[key]);
            sequelize[key].fabrixApp = app;
            sequelize[key].migrate = stores[key].migrate;
            sequelize[key].models = {};
        });
        return sequelize;
    },
    getModels(app, connections) {
        const models = exports.Transformer.pickModels(app, connections);
        const sModels = {};
        Object.keys(models).forEach(modelName => {
            sModels[modelName] = exports.Transformer.defineModel(app, models[modelName], connections).resolver.sequelizeModel;
        });
        exports.Transformer.associateModels(app, models, sModels);
        return sModels;
    },
    associateModels(app, models, sequelizeModels) {
        Object.keys(models).forEach(modelName => {
            if (models[modelName].constructor.hasOwnProperty('associate')) {
                models[modelName].constructor.associate(sequelizeModels);
            }
        });
    }
};
