"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const spool_router_1 = require("@fabrix/spool-router");
const path_1 = require("path");
const lodash_1 = require("lodash");
exports.Server = {
    registerPlugins(server, app) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!app.config.get('web.plugins')) {
                return;
            }
            app.log.debug('spool-hapi: registering', app.config.get('web.plugins').length, 'plugins');
            yield server.register(require('inert'));
            if (typeof app.config.get('web.onPluginsLoaded') === 'function') {
                app.config.get('web.onPluginsLoaded').call(app);
            }
        });
    },
    registerViews(server, app) {
        if (typeof server.views !== 'function') {
            return;
        }
        if (!app.config.get('views.engines')) {
            app.log.warn('spool-hapi: web.views.engines is not set. vision plugin will not load');
            return;
        }
        app.log.debug('spool-hapi: registering views');
        server.views(app.config.get('web.views'));
    },
    registerRoutes(server, app) {
        const serverRoutes = [];
        app.routes.forEach((route, path) => {
            spool_router_1.Utils.methods.forEach(m => {
                if (route[m]) {
                    serverRoutes.push({
                        path: path,
                        method: m,
                        handler: route[m].handler,
                        config: lodash_1.omit(route[m].config, 'prefix')
                    });
                }
            });
        });
        server.route(serverRoutes);
        if (app.config.get('main.paths.www')) {
            if (Array.isArray(app.config.get('main.paths.www'))) {
                app.config.get('main.paths.www').map(item => {
                    const staticDir = path_1.relative(app.config.get('main.paths.root'), item.path);
                    server.route({
                        method: 'GET',
                        path: item.humanUrl ?
                            item.humanUrl.concat('/{filename*}') :
                            '/'.concat(staticDir.replace(/\\/g, '/'), '/{filename*}'),
                        handler: {
                            file: function (request) {
                                return path_1.join(staticDir, request.params.filename);
                            }
                        }
                    });
                });
            }
            else {
                const staticDir = path_1.relative(app.config.get('main.paths.root'), app.config.get('main.paths.www'));
                server.route({
                    method: 'GET',
                    path: '/'.concat(staticDir.replace(/\\/g, '/'), '/{filename*}'),
                    handler: {
                        file: function (request) {
                            return path_1.join(staticDir, request.params.filename);
                        }
                    }
                });
            }
        }
        else {
            app.log.debug('config.paths.www: No www directory is set, static files will not be loaded');
        }
    },
    registerExtensions(server, app) {
        app.config.get('web.extensions').forEach(ext => {
            ext.method = ext.method.bind({ app });
            server.ext(ext);
        });
    }
};
