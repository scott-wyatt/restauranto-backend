"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const repl = require("repl");
const tool_1 = require("@fabrix/fabrix/dist/common/spools/tool");
const inspect_1 = require("./inspect");
const http_1 = require("./http");
const config = require("./config/index");
const pkg = require("../package.json");
class REPLSpool extends tool_1.ToolSpool {
    constructor(app) {
        super(app, {
            config: config,
            pkg: pkg,
            api: {}
        });
    }
    validate() {
    }
    configure() {
        inspect_1.Inspect.configureApp(this.app);
        inspect_1.Inspect.configureApi(this.app.api);
        inspect_1.Inspect.configureSpools(this.app.spools);
        http_1.Http.init(this.app);
        if (!this.config.historyFileName) {
            this.config.historyFileName = (process.env.NODE_REPL_HISTORY || '.node_repl_history').toString();
        }
        if (!this.config.historySize) {
            this.config.historySize = Number(process.env.NODE_REPL_HISTORY_SIZE || 1000);
        }
        this.historyFile = path_1.resolve(this.app.config.get('main.paths.temp'), this.config.historyFileName);
        this.app.log.debug('historyFile', this.historyFile);
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!process.stdout.isTTY) {
                this.app.log.info('spool-repl: No text terminal available. ');
                if (!this.app.config.get('repl.allowNoTTY')) {
                    this.app.log.info('spool-repl: REPL not started. Continuing.');
                    this.app.log.debug('spool-repl: Set config.repl.allowNoTTY=true to override');
                    return;
                }
                else {
                    this.app.log.warn('spool-repl: allowNoTTY is enabled, Launching REPL anyway.');
                }
            }
            try {
                const replOptions = {
                    prompt: '',
                    useColors: true,
                    replMode: process.env.REPL_MODE_STRICT,
                    historySize: this.config.historySize
                };
                this.server = repl.start(replOptions);
                this.server.pause();
                this.app.once('fabrix:ready', () => {
                    this.server.setPrompt('\u001b[1;32mfabrix > \u001b[0m');
                    this.server.resume();
                    this.server.write('', { name: 'return' });
                });
            }
            catch (e) {
                this.app.log.error(e);
                this.app.log.warn('spool-repl: Disabling REPL.');
                return;
            }
            try {
                fs_1.statSync(this.historyFile);
                fs_1.readFileSync(this.historyFile).toString()
                    .split('\n')
                    .reverse()
                    .slice(0, this.config.historySize)
                    .filter(line => line.trim())
                    .map(line => this.server.history.push(line));
            }
            catch (e) {
                this.app.log.silly('Could not read REPL history file at', this.historyFile);
                this.app.log.silly('No problem, a history file will be created on shutdown');
            }
            this.server.once('exit', () => {
                this.app.stop().then(() => process.exit());
            });
            this.server.context.app = this.app;
            this.server.context.get = http_1.Http.get.bind(http_1.Http);
            this.server.context.post = http_1.Http.post.bind(http_1.Http);
            this.server.context.put = http_1.Http.put.bind(http_1.Http);
            this.server.context.delete = http_1.Http.delete.bind(http_1.Http);
            this.server.context.patch = http_1.Http.patch.bind(http_1.Http);
            this.server.context.head = http_1.Http.head.bind(http_1.Http);
            this.server.context.options = http_1.Http.options.bind(http_1.Http);
        });
    }
    addCommand(command, handler) {
        if (this.server) {
            this.server.context[command] = handler;
        }
    }
    unload() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!process.stdout.isTTY && !this.app.config.get('repl.allowNoTTY')) {
                return;
            }
            this.server.removeAllListeners('exit');
            this.server.close();
            try {
                const lines = (this.server.history || [])
                    .reverse()
                    .filter(line => line.trim())
                    .join('\n');
                fs_1.writeFileSync(this.historyFile, lines);
            }
            catch (e) {
                this.app.log.debug(e);
                this.app.log.warn('Could not create REPL history file at', this.historyFile);
                this.app.log.warn('This is strange, but not fatal. Set loglevel to "debug" for more info');
            }
            inspect_1.Inspect.unconfigureApp(this.app);
            inspect_1.Inspect.unconfigureApi(this.app.api);
            inspect_1.Inspect.unconfigureSpools(this.app.spools);
        });
    }
}
exports.REPLSpool = REPLSpool;
