"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const path_1 = require("path");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
const Core_1 = require("./Core");
const ConfigurationProxyHandler = {
    get(target, key) {
        if (target.has && target.has(key)) {
            const value = target.immutable === true ? Object.freeze(target.get(key)) : target.get(key);
            return new Proxy(value, ConfigurationProxyHandler);
        }
        else {
            return target.immutable === true ? Object.freeze(target[key]) : target[key];
        }
    }
};
class Configuration extends Map {
    static flattenTree(tree = {}) {
        const toReturn = {};
        try {
            Object.entries(tree).forEach(([k, v]) => {
                if (v !== null
                    && v instanceof Object
                    && typeof v !== 'function') {
                    if (Array.isArray(v)) {
                        v.forEach((val, i) => {
                            toReturn[`${k}.${i}`] = val;
                        });
                    }
                    else if (!Core_1.Core.isNotCircular(v)) {
                        toReturn[k] = v;
                    }
                    else {
                        const flatObject = Configuration.flattenTree(v);
                        Object.keys(flatObject).forEach(flatKey => {
                            toReturn[`${k}.${flatKey}`] = flatObject[flatKey];
                        });
                    }
                }
                toReturn[k] = v;
            });
            return toReturn;
        }
        catch (err) {
            if (err !== Core_1.Core.BreakException) {
                throw new RangeError('Tree is circular and can not be resolved, check that there are no circular references in the config');
            }
            return toReturn;
        }
    }
    static initialResources(tree, resources = []) {
        if (tree.hasOwnProperty('main') && tree.main.hasOwnProperty('resources')) {
            if (!lodash_1.isArray(tree.main['resources'])) {
                throw new errors_1.ConfigValueError('if set, main.resources must be an array');
            }
            return tree.main['resources'];
        }
        else {
            return resources;
        }
    }
    static buildConfig(initialConfig = {}, nodeEnv) {
        const root = path_1.resolve(path_1.dirname(utils_1.requireMainFilename()));
        const temp = path_1.resolve(root, '.tmp');
        const envConfig = initialConfig.env && initialConfig.env[nodeEnv] || {};
        const configTemplate = {
            main: {
                resources: Configuration.initialResources(initialConfig),
                lockResources: false,
                maxListeners: 128,
                spools: [],
                paths: {
                    root: root,
                    temp: temp,
                    sockets: path_1.resolve(temp, 'sockets'),
                    logs: path_1.resolve(temp, 'log')
                },
                freezeConfig: true,
                createPaths: true
            }
        };
        return lodash_1.merge(configTemplate, initialConfig, envConfig, { env: nodeEnv });
    }
    constructor(configTree = {}, processEnv = {}) {
        const config = Configuration.buildConfig(configTree, processEnv['NODE_ENV']);
        const configEntries = Object.entries(Configuration.flattenTree(config));
        super(configEntries);
        this.immutable = false;
        this.env = processEnv;
        this.get = this.get.bind(this);
        this.set = this.set.bind(this);
        this.entries = this.entries.bind(this);
        this.has = this.has.bind(this);
        return new Proxy(this, ConfigurationProxyHandler);
    }
    _reverseFlattenSet(key, value) {
        if (/\.[0-9a-z]+$/.test(key)) {
            const decedent = (key).match(/\.([0-9a-z]+)$/)[1];
            const parent = key.replace(/\.[0-9a-z]+$/, '');
            const proto = Array.isArray(value) ? [] : {};
            const newParentValue = Core_1.Core.defaultsDeep({ [decedent]: value }, this.get(parent) || proto);
            super.set(key, value);
            return this._reverseFlattenSet(parent, newParentValue);
        }
        else {
            return super.set(key, value);
        }
    }
    _flattenSet(key, value) {
        if (value !== null
            && value instanceof Object
            && typeof value !== 'function'
            && !Array.isArray(value)) {
            const configEntries = Object.entries(Configuration.flattenTree({ [key]: value }));
            configEntries.forEach(([_key, _value]) => {
                return super.set(_key, _value);
            });
        }
        return this._reverseFlattenSet(key, value);
    }
    set(key, value) {
        if (this.immutable === true) {
            throw new errors_1.IllegalAccessError('Cannot set properties directly on config. Use .set(key, value) (immutable)');
        }
        return this._flattenSet(key, value);
    }
    merge(configTree, configAction = 'hold') {
        const configEntries = Object.entries(Configuration.flattenTree(configTree));
        return configEntries.map(([key, value]) => {
            const hasKey = this.has(key);
            if (!hasKey || configAction === 'hold') {
                this.set(key, value);
            }
            else if (hasKey && configAction === 'merge') {
                if (value === null) {
                }
                else if (typeof value === 'undefined') {
                }
                else if (Array.isArray(value)) {
                }
                else if (typeof value === 'number') {
                }
                else if (typeof value === 'string') {
                }
                else if (typeof value === 'function') {
                }
                else {
                    this.set(key, Core_1.Core.defaultsDeep(this.get(key), value));
                }
            }
            else if (hasKey && configAction === 'replaceable') {
            }
            return { hasKey, key };
        });
    }
    freeze() {
        this.immutable = true;
    }
    unfreeze() {
        this.immutable = false;
    }
}
exports.Configuration = Configuration;
