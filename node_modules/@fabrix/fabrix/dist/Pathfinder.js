"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("./errors");
const lifecycleStages = [
    'configure',
    'initialize'
];
exports.Pathfinder = {
    isComplete(spools) {
        return spools.every(spool => {
            return exports.Pathfinder.isLifecycleValid(spool, spools);
        });
    },
    isLifecycleValid(spool, spools) {
        return lifecycleStages.every(stageName => {
            return exports.Pathfinder.isLifecycleStageValid(spool, stageName, spools);
        });
    },
    isLifecycleStageValid(spool, stageName, spools) {
        if (!stageName || lifecycleStages.indexOf(stageName) === -1) {
            throw new TypeError(`isLifecycleStageValid: stageName must be one of ${lifecycleStages}`);
        }
        const path = exports.Pathfinder.getLifecyclePath(spool, stageName, spools);
        const terminals = exports.Pathfinder.getPathErrors(path);
        return !terminals.some((t) => t instanceof Error);
    },
    getPathErrors(path) {
        if (typeof path === 'boolean') {
            return [];
        }
        if (path instanceof Error) {
            return [path];
        }
        return Object.keys(path)
            .map(key => exports.Pathfinder.getPathErrors(path[key]))
            .reduce((terminals, t) => terminals.concat(t), []);
    },
    getLifecyclePath(spool, stageName, spools, path) {
        const stage = spool.lifecycle[stageName] || {};
        if (!path) {
            return exports.Pathfinder.getLifecyclePath(spool, stageName, spools, [spool]);
        }
        if (!stage.listen || (stage.listen && stage.listen.length === 0)) {
            return true;
        }
        const producers = stage.listen
            .map((eventName) => {
            return exports.Pathfinder.getEventProducer(eventName, stageName, spools, path);
        })
            .filter((producer) => !!producer);
        const error = producers.find((producer) => producer instanceof errors_1.GraphCompletenessError);
        if (error) {
            return error;
        }
        return producers.reduce((level, producer) => {
            const subpath = path.concat(producer);
            level[producer.name] = exports.Pathfinder.getLifecyclePath(producer, stageName, spools, subpath);
            return level;
        }, {});
    },
    getEventProducer(eventName, stageName, spools, path = []) {
        const producers = spools
            .filter(spool => {
            const stage = spool.lifecycle[stageName];
            return path.indexOf(spool) === -1 && stage.emit.indexOf(eventName) >= 0;
        });
        if (producers.length > 1) {
            return new Error(`More than one spool produces the event ${eventName}`);
        }
        if (producers.length === 0) {
            return new errors_1.GraphCompletenessError(path[path.length - 1], stageName, eventName);
        }
        return producers[0];
    }
};
