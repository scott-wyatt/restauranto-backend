"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const mkdirp = require("mkdirp");
const _1 = require("./");
const errors_1 = require("./errors");
const Service_1 = require("./common/Service");
const Controller_1 = require("./common/Controller");
const Policy_1 = require("./common/Policy");
const Model_1 = require("./common/Model");
const Resolver_1 = require("./common/Resolver");
exports.Errors = {
    ApiNotDefinedError: errors_1.ApiNotDefinedError,
    ConfigNotDefinedError: errors_1.ConfigNotDefinedError,
    ConfigValueError: errors_1.ConfigValueError,
    GraphCompletenessError: errors_1.GraphCompletenessError,
    IllegalAccessError: errors_1.IllegalAccessError,
    NamespaceConflictError: errors_1.NamespaceConflictError,
    PackageNotDefinedError: errors_1.PackageNotDefinedError,
    TimeoutError: errors_1.TimeoutError,
    SanityError: errors_1.SanityError,
    SpoolError: errors_1.SpoolError,
    ValidationError: errors_1.ValidationError
};
exports.Core = {
    BreakException: {},
    reservedMethods: [
        'app',
        'api',
        'log',
        '__',
        'constructor',
        'undefined',
        'methods',
        'config',
        'schema',
        'services',
        'models'
    ],
    globals: Object.freeze(Object.assign({
        Service: Service_1.FabrixService,
        Controller: Controller_1.FabrixController,
        Policy: Policy_1.FabrixPolicy,
        Model: Model_1.FabrixModel,
        Resolver: Resolver_1.FabrixResolver
    }, exports.Errors)),
    globalPropertyOptions: Object.freeze({
        writable: false,
        enumerable: false,
        configurable: false
    }),
    assignGlobals() {
        Object.entries(exports.Core.globals).forEach(([name, type]) => {
            if (global[name] === type) {
                return;
            }
            if (global[name] && global[name] !== type) {
                throw new errors_1.NamespaceConflictError(name, Object.keys(exports.Core.globals));
            }
            const descriptor = Object.assign({ value: type }, exports.Core.globalPropertyOptions);
            Object.defineProperty(global, name, descriptor);
        });
    },
    bindMethods(app, resource) {
        return Object.entries(app.api[resource] || {})
            .map(([resourceName, Resource]) => {
            const objContext = Resource;
            const obj = new objContext(app);
            obj.methods = exports.Core.getClassMethods(obj) || [];
            Object.entries(obj.methods).forEach(([_, method]) => {
                obj[method] = obj[method].bind(obj);
            });
            return [resourceName, obj];
        })
            .reduce((result, [resourceName, _resource]) => Object.assign(result, {
            [resourceName]: _resource
        }), {});
    },
    bindResourceMethods(app, resources) {
        resources.forEach(resource => {
            try {
                app[resource] = exports.Core.bindMethods(app, resource);
            }
            catch (err) {
                app.log.error(err);
            }
        });
    },
    getClassMethods(obj) {
        const props = [];
        const objectRoot = new Object();
        while (!obj.isPrototypeOf(objectRoot)) {
            Object.getOwnPropertyNames(obj).forEach(prop => {
                if (props.indexOf(prop) === -1
                    && !exports.Core.reservedMethods.some(p => p === prop)
                    && typeof obj[prop] === 'function') {
                    props.push(prop);
                }
            });
            obj = Object.getPrototypeOf(obj);
        }
        return props;
    },
    getPropertyNames(obj) {
        return Object.getOwnPropertyNames(obj.prototype);
    },
    hasPrototypeProperty(obj, proto) {
        return obj.prototype.hasOwnProperty(proto);
    },
    mergePrototype(obj, next, proto) {
        obj.prototype[proto] = next.prototype[proto];
    },
    mergeApi(app) {
        const spools = Object.keys(app.spools).reverse();
        app.resources.forEach(resource => {
            spools.forEach(s => {
                lodash_1.defaultsDeep(app.api, app.spools[s].api);
                exports.Core.mergeApiResource(app, app.spools[s], resource);
            });
        });
    },
    mergeApiResource(app, spool, resource) {
        if (app.api.hasOwnProperty(resource) && spool.api.hasOwnProperty(resource)) {
            Object.keys(spool.api[resource]).forEach(method => {
                exports.Core.mergeApiResourceMethod(app, spool, resource, method);
            });
        }
    },
    mergeApiResourceMethod(app, spool, resource, method) {
        if (spool.api[resource].hasOwnProperty(method) && app.api[resource].hasOwnProperty(method)) {
            const spoolProto = exports.Core.getPropertyNames(spool.api[resource][method]);
            spoolProto.forEach(proto => {
                if (!exports.Core.hasPrototypeProperty(app.api[resource][method], proto)) {
                    exports.Core.mergePrototype(app.api[resource][method], spool.api[resource][method], proto);
                    app.log.silly(`${spool.name}.api.${resource}.${method}.${proto} extending app.api.${resource}.${method}.${proto}`);
                }
            });
        }
    },
    mergeSpoolApi(app, spool) {
        app.resources = lodash_1.union(app.resources, Object.keys(app.api), Object.keys(spool.api));
        const spools = Object.keys(app.spools)
            .filter(s => s !== spool.name);
        app.resources.forEach(resource => {
            spools.forEach(s => {
                exports.Core.mergeSpoolApiResource(app, app.spools[s], spool, resource);
            });
        });
    },
    mergeSpoolApiResource(app, spool, next, resource) {
        if (spool && spool.api.hasOwnProperty(resource) && next.api.hasOwnProperty(resource)) {
            Object.keys(next.api[resource]).forEach(method => {
                exports.Core.mergeSpoolApiResourceMethod(app, spool, next, resource, method);
            });
        }
    },
    mergeSpoolApiResourceMethod(app, spool, next, resource, method) {
        if (spool && spool.api[resource].hasOwnProperty(method) && next.api[resource].hasOwnProperty(method)) {
            const spoolProto = exports.Core.getPropertyNames(spool.api[resource][method]);
            spoolProto.forEach(proto => {
                if (!exports.Core.hasPrototypeProperty(next.api[resource][method], proto)) {
                    exports.Core.mergePrototype(next.api[resource][method], spool.api[resource][method], proto);
                    app.log.silly(`${spool.name}.api.${resource}.${method}.${proto} extending ${next.name}.api.${resource}.${method}.${proto}`);
                }
            });
        }
    },
    mergeExtensions(app, spool) {
        const extensions = spool.extensions || {};
        for (const ext of Object.keys(extensions)) {
            if (!extensions.hasOwnProperty(ext)) {
                continue;
            }
            if (app.hasOwnProperty(ext)) {
                app.log.warn(`Spool Extension ${spool.name}.${ext} overriding app.${ext}`);
            }
            Object.defineProperty(app, ext, spool.extensions[ext]);
        }
    },
    defaultsDeep: (...args) => {
        const output = {};
        lodash_1.toArray(args).reverse().forEach(function (item) {
            lodash_1.mergeWith(output, item, function (objectValue, sourceValue) {
                return lodash_1.isArray(sourceValue) ? sourceValue : undefined;
            });
        });
        return output;
    },
    collector: (stack, key, val) => {
        let idx = stack[stack.length - 1].indexOf(key);
        try {
            const props = Object.keys(val);
            if (!props.length) {
                throw props;
            }
            props.unshift({ idx: idx });
            stack.push(props);
        }
        catch (e) {
            while (!(stack[stack.length - 1].length - 2)) {
                idx = stack[stack.length - 1][0].idx;
                stack.pop();
            }
            if (idx + 1) {
                stack[stack.length - 1].splice(idx, 1);
            }
        }
        return val;
    },
    isNotCircular: (obj) => {
        let stack = [[]];
        try {
            return !!JSON.stringify(obj, exports.Core.collector.bind(null, stack));
        }
        catch (e) {
            if (e.message.indexOf('circular') !== -1) {
                let idx = 0;
                let path = '';
                let parentProp = '';
                while (idx + 1) {
                    idx = stack.pop()[0].idx;
                    parentProp = stack[stack.length - 1][idx];
                    if (!parentProp) {
                        break;
                    }
                    path = '.' + parentProp + path;
                }
            }
            return false;
        }
    },
    createDefaultPaths(app) {
        return __awaiter(this, void 0, void 0, function* () {
            const paths = app.config.get('main.paths') || {};
            for (const [, dir] of Object.entries(paths)) {
                yield mkdirp(dir, null, function (err) {
                    if (err) {
                        app.log.error(err);
                    }
                });
            }
        });
    },
    bindApplicationListeners(app) {
        app.once('spool:all:configured', () => {
            if (app.config.get('main.freezeConfig') === false) {
                app.log.warn('freezeConfig is disabled. Configuration will not be frozen.');
                app.log.warn('Please only use this flag for testing/debugging purposes.');
            }
            else {
                app.config.freeze();
            }
        });
        app.once('spool:all:initialized', () => {
            app.log.silly(_1.Templates.silly.initialized);
            app.log.info(_1.Templates.info.initialized);
        });
        app.once('spool:all:sane', () => {
            app.log.silly(_1.Templates.silly.sane);
            app.log.info(_1.Templates.info.sane);
        });
        app.once('fabrix:ready', () => {
            app.log.info(_1.Templates.info.ready(app));
            app.log.debug(_1.Templates.debug.ready(app));
            app.log.silly(_1.Templates.silly.ready(app));
            app.log.info(_1.Templates.hr);
            app.log.info(_1.Templates.docs);
        });
        app.once('fabrix:stop', () => {
            app.log.info(_1.Templates.info.stop);
            app.config.unfreeze();
        });
    },
    bindSpoolPhaseListeners(app, spools) {
        const validatedEvents = spools.map(spool => `spool:${spool.name}:validated`);
        const configuredEvents = spools.map(spool => `spool:${spool.name}:configured`);
        const initializedEvents = spools.map(spool => `spool:${spool.name}:initialized`);
        const sanityEvents = spools.map(spool => `spool:${spool.name}:sane`);
        app.after(configuredEvents).then(() => __awaiter(this, void 0, void 0, function* () {
            yield this.createDefaultPaths(app);
            app.emit('spool:all:configured');
        }));
        app.after(validatedEvents)
            .then(() => app.emit('spool:all:validated'));
        app.after(initializedEvents)
            .then(() => {
            app.emit('spool:all:initialized');
        });
        app.after(sanityEvents)
            .then(() => {
            app.emit('spool:all:sane');
            app.emit('fabrix:ready');
        });
    },
    bindSpoolMethodListeners(app, spool) {
        const lifecycle = spool.lifecycle;
        app.after((lifecycle.sanity.listen).concat('spool:all:initialized'))
            .then(() => app.log.debug('spool: sanity check', spool.name))
            .then(() => spool.stage = 'sanity')
            .then(() => spool.sanity())
            .then(() => app.emit(`spool:${spool.name}:sane`))
            .then(() => spool.stage = 'sane')
            .catch(this.handlePromiseRejection);
        app.after((lifecycle.initialize.listen).concat('spool:all:configured'))
            .then(() => app.log.debug('spool: initializing', spool.name))
            .then(() => spool.stage = 'initializing')
            .then(() => spool.initialize())
            .then(() => app.emit(`spool:${spool.name}:initialized`))
            .then(() => spool.stage = 'initialized')
            .catch(this.handlePromiseRejection);
        app.after((lifecycle.configure.listen).concat('spool:all:validated'))
            .then(() => app.log.debug('spool: configuring', spool.name))
            .then(() => spool.stage = 'configuring')
            .then(() => spool.configure())
            .then(() => app.emit(`spool:${spool.name}:configured`))
            .then(() => spool.stage = 'configured')
            .catch(this.handlePromiseRejection);
        app.after('fabrix:start')
            .then(() => app.log.debug('spool: validating', spool.name))
            .then(() => spool.stage = 'validating')
            .then(() => spool.validate())
            .then(() => app.emit(`spool:${spool.name}:validated`))
            .then(() => spool.stage = 'validated')
            .catch(this.handlePromiseRejection);
    },
    handlePromiseRejection(err) {
        console.error(err);
        throw err;
    }
};
