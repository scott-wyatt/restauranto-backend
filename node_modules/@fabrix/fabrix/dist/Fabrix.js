"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const lodash_1 = require("lodash");
const Core_1 = require("./Core");
const Configuration_1 = require("./Configuration");
const LoggerProxy_1 = require("./LoggerProxy");
const common_1 = require("./common");
const Errors = require("./errors");
const pkg = require("../package.json");
Core_1.Core.assignGlobals();
class FabrixApp extends events_1.EventEmitter {
    constructor(app) {
        super();
        this._resources = [];
        if (!app) {
            throw new RangeError('No app definition provided to Fabrix constructor');
        }
        if (!app.pkg) {
            throw new Errors.PackageNotDefinedError();
        }
        if (!app.api) {
            throw new Errors.ApiNotDefinedError();
        }
        if (!process.env.NODE_ENV) {
            process.env.NODE_ENV = 'development';
        }
        const processEnv = Object.freeze(Object.assign({}, JSON.parse(JSON.stringify(process.env))));
        Object.defineProperties(this, {
            _logger: {
                value: new LoggerProxy_1.LoggerProxy(this),
                enumerable: false
            },
            _env: {
                value: processEnv,
                enumerable: false
            },
            _pkg: {
                value: app.pkg,
                enumerable: false
            },
            _versions: {
                value: process.versions,
                enumerable: false
            },
            _config: {
                value: new Configuration_1.Configuration(app.config, processEnv),
                enumerable: false
            },
            _spools: {
                value: {},
                enumerable: false
            },
            _api: {
                value: app.api,
                enumerable: false
            },
            _fabrix: {
                value: pkg,
                enumerable: false
            }
        });
        this.setMaxListeners(this.config.get('main.maxListeners'));
        this._resources = this.config.get('main.resources');
        this.resources = lodash_1.union(Object.keys(app.api), this.config.get('main.resources'));
        this.resources.forEach(resource => {
            app.api[resource] = app.api[resource] || (app.api[resource] = {});
        });
        this.config.get('main.spools').forEach((NewSpool) => {
            try {
                const spoolContext = NewSpool;
                const spool = new spoolContext(this, {});
                this.spools[spool.name] = spool;
                this.config.merge(spool.config, spoolContext.configAction);
                Core_1.Core.mergeExtensions(this, spool);
                Core_1.Core.mergeSpoolApi(this, spool);
                Core_1.Core.bindSpoolMethodListeners(this, spool);
            }
            catch (e) {
                console.log(e.stack);
                throw new Errors.SpoolError(common_1.Spool, e, 'constructor');
            }
        });
        Core_1.Core.mergeApi(this);
        Core_1.Core.bindResourceMethods(this, this.resources);
        Core_1.Core.bindApplicationListeners(this);
        Core_1.Core.bindSpoolPhaseListeners(this, Object.values(this.spools));
        this.emit('fabrix:constructed');
    }
    get logger() {
        return this._logger;
    }
    get env() {
        return this._env;
    }
    get pkg() {
        return this._pkg;
    }
    get versions() {
        return this._versions;
    }
    get config() {
        return this._config;
    }
    get fabrix() {
        return this._fabrix;
    }
    get spools() {
        return this._spools;
    }
    get api() {
        return this._api;
    }
    get log() {
        return this.logger;
    }
    set resources(values) {
        if (!this.config.get('main.lockResources')) {
            this._resources = Object.assign([], Configuration_1.Configuration.initialResources(this.config, values));
            this.config.set('main.resources', this._resources);
        }
    }
    get resources() {
        return this._resources;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('fabrix:start');
            yield this.after('fabrix:ready');
            return this;
        });
    }
    stop(error) {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('fabrix:stop');
            if (error) {
                this.emit('fabrix:stop:error', error);
            }
            yield Promise
                .all(Object.values(this.spools).map(spool => {
                spool.stage = 'unloading';
                this.log.debug('Unloading spool', spool.name, '...');
                return spool.unload();
            }))
                .then(() => {
                Object.values(this.spools).forEach(spool => { spool.stage = 'unloaded'; });
                this.log.debug('All spools unloaded. Done.');
                this.removeAllListeners();
            })
                .catch(err => {
                this.log.error(err, 'while handling stop.');
                throw err;
            });
            return this;
        });
    }
    onceAny(events) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!Array.isArray(events)) {
                events = [events];
            }
            let resolveCallback;
            return Promise
                .race(events.map((eventName) => {
                return new Promise(resolve => {
                    resolveCallback = resolve;
                    this.once(eventName, resolveCallback);
                });
            }))
                .then((...args) => {
                events.forEach((eventName) => this.removeListener(eventName, resolveCallback));
                return args;
            })
                .catch(err => {
                this.log.error(err, 'handling onceAny events', events);
                throw err;
            });
        });
    }
    after(events) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!Array.isArray(events)) {
                events = [events];
            }
            return Promise
                .all(events.map((eventName) => {
                return new Promise(resolve => {
                    if (eventName instanceof Array) {
                        resolve(this.onceAny(eventName));
                    }
                    else {
                        this.once(eventName, resolve);
                    }
                });
            }))
                .catch(err => {
                this.log.error(err, 'handling after events', events);
                throw err;
            });
        });
    }
}
exports.FabrixApp = FabrixApp;
