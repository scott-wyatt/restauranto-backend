"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const _1 = require("./");
const errors_1 = require("../errors");
const Generic_1 = require("./Generic");
class FabrixModel extends Generic_1.FabrixGeneric {
    static config(app, datastore) {
        return {
            tableName: null,
            store: null,
            migrate: null
        };
    }
    static schema(app, datastore) {
        return {};
    }
    static get resolver() {
        return _1.FabrixResolver;
    }
    constructor(app, datastore) {
        if (!(app instanceof events_1.EventEmitter)) {
            throw new Error('The "app" argument must be of type EventEmitter');
        }
        super(app);
        this._datastore = datastore;
        this.resolver = new this.constructor.resolver(this, datastore);
        this.app.emit(`model:${this.name}:constructed`, this);
    }
    get datastore() {
        if (!this._datastore) {
        }
        return this._datastore;
    }
    set datastore(datastore) {
        this._datastore = datastore;
    }
    get instance() {
        if (!this._resolver) {
            return;
        }
        return this._resolver.instance;
    }
    get config() {
        if (!this._config) {
            this._config = this.constructor.config;
        }
        return this._config;
    }
    get schema() {
        if (!this._schema) {
            this._schema = this.constructor.config;
        }
        return this._schema;
    }
    set resolver(r) {
        if (this.resolver) {
            throw new errors_1.IllegalAccessError('Cannot change the resolver on a Model');
        }
        this._resolver = r;
    }
    get resolver() {
        return this._resolver;
    }
    get name() {
        return this.constructor.name.toLowerCase();
    }
    get tableName() {
        const config = this.constructor.config(this.app, this.datastore);
        return config.tableName || this.name;
    }
}
exports.FabrixModel = FabrixModel;
