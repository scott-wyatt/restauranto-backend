"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
exports.Utils = {
    methods: [
        'GET',
        'HEAD',
        'POST',
        'PUT',
        'DELETE',
        'CONNECT',
        'OPTIONS',
        'TRACE',
        'PATCH'
    ],
    stringToArray(strOrArray) {
        return lodash_1.isString(strOrArray) ? [strOrArray] : strOrArray;
    },
    splitRoute(app, path, rawRoute) {
        const methods = ['*', ...exports.Utils.methods];
        const routeMethods = new Set();
        const usedPrefixes = new Set();
        const orgRoute = Object.assign({}, rawRoute);
        const parentPrefix = lodash_1.get(orgRoute, 'config.prefix');
        orgRoute.config = orgRoute.config || (orgRoute.config = {});
        orgRoute.config.pre = orgRoute.config.pre || (orgRoute.config.pre = []);
        if (typeof parentPrefix !== 'undefined') {
            usedPrefixes.add(parentPrefix);
        }
        const cases = new Set();
        methods.forEach(method => {
            if (orgRoute.hasOwnProperty(method)) {
                const methodPrefix = lodash_1.get(rawRoute[method], 'config.prefix');
                routeMethods.add({ [method]: methodPrefix });
                if (typeof methodPrefix !== 'undefined') {
                    usedPrefixes.add(methodPrefix);
                }
                if (method === '*' && methodPrefix) {
                    cases.add(1);
                }
                if (typeof parentPrefix === 'undefined' && methodPrefix && usedPrefixes.size > 1) {
                    cases.add(4);
                }
            }
        });
        if (typeof parentPrefix !== 'undefined'
            && usedPrefixes.size === 1) {
            cases.add(2);
        }
        if (typeof parentPrefix === 'undefined'
            && usedPrefixes.size === 1) {
            cases.add(3);
        }
        if (typeof parentPrefix !== 'undefined'
            && routeMethods.size === 1
            && usedPrefixes.size > 1) {
            cases.add(5);
        }
        const scenarios = {
            '1': cases.has(1),
            '2': cases.has(2),
            '3': cases.has(3),
            '4': cases.has(4),
            '5': cases.has(5)
        };
        const type = Object.keys(scenarios).find((key) => scenarios[key]);
        switch (type) {
            case '1': {
                orgRoute.config.prefix = orgRoute['*'].config.prefix;
                return exports.Utils.buildRoute(app, path, orgRoute);
            }
            case '2': {
                return exports.Utils.buildRoute(app, path, orgRoute);
            }
            case '3': {
                orgRoute.config.prefix = usedPrefixes.values().next().value;
                return exports.Utils.buildRoute(app, path, orgRoute);
            }
            case '4': {
                const routes = new Set();
                const newRoutes = new Map();
                routeMethods.forEach(route => {
                    const method = Object.keys(route)[0];
                    const prefix = route[method];
                    if (prefix !== parentPrefix) {
                        const newRoute = {
                            [method]: orgRoute[method],
                            config: {
                                prefix: prefix
                            }
                        };
                        if (newRoutes.has(prefix)) {
                            newRoutes.set(prefix, Object.assign({}, newRoute, newRoutes.get(prefix)));
                        }
                        else {
                            newRoutes.set(prefix, newRoute);
                        }
                        delete orgRoute[method];
                    }
                });
                newRoutes.forEach(newRoute => {
                    routes.add(exports.Utils.buildRoute(app, path, newRoute));
                });
                routes.add(exports.Utils.buildRoute(app, path, orgRoute));
                return Array.from(routes).reduce((a, b) => a.concat(b), []);
            }
            case '5': {
                orgRoute.config.prefix = Array.from(usedPrefixes).pop();
                return exports.Utils.buildRoute(app, path, orgRoute);
            }
            default: {
                return exports.Utils.buildRoute(app, path, orgRoute);
            }
        }
    },
    buildRoute(app, path, rawRoute) {
        const orgRoute = Object.assign({}, rawRoute);
        orgRoute.config = orgRoute.config || (orgRoute.config = {});
        orgRoute.config.pre = orgRoute.config.pre || (orgRoute.config.pre = []);
        if (app.config.get('router.debug')) {
            orgRoute._orgPath = path;
        }
        path = exports.Utils.getPathFromRoute(app, path, orgRoute);
        if (app.config.get('router.debug')) {
            orgRoute._newPath = path;
        }
        exports.Utils.getHandlerFromString(app, orgRoute);
        orgRoute.config.pre = orgRoute.config.pre
            .map(pre => exports.Utils.getPolicyFromPrerequisite(app, pre))
            .filter(handler => !!handler);
        const orgRouteHandlers = Object.keys(orgRoute)
            .filter(value => -1 !== exports.Utils.methods.indexOf(value));
        if (!orgRouteHandlers.some(v => exports.Utils.methods.indexOf(v) >= 0 || !!orgRoute[v])) {
            app.log.error('spool-router: route ', path, ' handler [', orgRouteHandlers.join(', '), ']', 'does not correspond to any defined Controller handler');
            return [];
        }
        orgRouteHandlers.forEach(method => {
            if (orgRoute[method]) {
                orgRoute[method].config = orgRoute[method].config || orgRoute.config;
                orgRoute[method].config.pre = orgRoute[method].config.pre || orgRoute.config.pre;
                orgRoute[method].config.pre = orgRoute[method].config.pre
                    .map(pre => exports.Utils.getPolicyFromPrerequisite(app, pre))
                    .filter(handler => !!handler);
            }
        });
        const route = lodash_1.omit(orgRoute, 'config');
        return [{ path, route }];
    },
    getRouteLevelPrefix(app, route) {
        const configuredPrefix = app.config.get(route.config.prefix);
        const routePrefix = lodash_1.get(route, 'config.prefix');
        if (typeof configuredPrefix !== 'undefined') {
            if (configuredPrefix) {
                return (configuredPrefix).replace(/$\//, '');
            }
            else {
                return;
            }
        }
        else {
            return (routePrefix || '').replace(/$\//, '');
        }
    },
    getPrefix(app, route) {
        if (!route || !(route instanceof Object)) {
            throw new RangeError('Expected a route object');
        }
        const hasPrefix = route.config && route.config.hasOwnProperty('prefix') && route.config.prefix !== false;
        const ignorePrefix = route.config && route.config.hasOwnProperty('prefix') && route.config.prefix === false;
        const routeLevelPrefix = hasPrefix ? exports.Utils.getRouteLevelPrefix(app, route) : null;
        const prefix = (app.config.get('router.prefix') || '').replace(/$\//, '');
        return `${ignorePrefix ? '' : routeLevelPrefix || prefix}`;
    },
    getPathFromRoute(app, path, route) {
        if (!route || !(route instanceof Object)) {
            throw new RangeError('Expected a route object');
        }
        path = path.replace(/^\//, '');
        const prefix = exports.Utils.getPrefix(app, route);
        return `${prefix}/${path}`;
    },
    getPolicyFromString(app, handler) {
        return lodash_1.get(app.policies, handler);
    },
    getControllerPolicy(app, handler, routeMethod, pre = []) {
        const controller = exports.Utils.getControllerFromHandler(handler);
        if (app.config.get('policies.*.*')) {
            pre = [...new Set([...pre, ...exports.Utils.stringToArray(app.config.get('policies.*.*'))])];
        }
        if (app.config.get(`policies.*.${routeMethod}`)) {
            pre = [...new Set([...pre, ...exports.Utils.stringToArray(app.config.get(`policies.*.${routeMethod}`))])];
        }
        if (handler && controller && app.config.get(`policies.${controller}.*.*`)) {
            pre = [...new Set([...pre, ...exports.Utils.stringToArray(app.config.get(`policies.${controller}.*.*`))])];
        }
        if (handler && controller && app.config.get(`policies.${controller}.*.${routeMethod}`)) {
            pre = [...new Set([...pre, ...exports.Utils.stringToArray(app.config.get(`policies.${controller}.*.${routeMethod}`))])];
        }
        if (handler && app.config.get(`policies.${handler}.${routeMethod}`)) {
            pre = [...new Set([...pre, ...exports.Utils.stringToArray(app.config.get(`policies.${handler}.${routeMethod}`))])];
        }
        return pre;
    },
    getPolicyFromPrerequisite(app, pre) {
        let handler;
        if (pre && typeof pre === 'string') {
            handler = exports.Utils.getPolicyFromString(app, pre);
        }
        else if (pre && Array.isArray(pre)) {
            handler = pre.map(p => exports.Utils.getPolicyFromString(app, p)).filter(p => p);
        }
        else if (pre && typeof pre.method === 'string') {
            handler = exports.Utils.getPolicyFromString(app, pre.method);
        }
        else if (pre && typeof pre === 'function') {
            handler = pre;
        }
        if (!handler) {
            app.log.error('spool-router: route prerequisite [', pre, ']', 'does not correspond to any defined Policy handler');
            return;
        }
        return handler;
    },
    getControllerFromString(app, handler) {
        return lodash_1.get(app.controllers, handler);
    },
    getControllerFromHandler(handler) {
        return lodash_1.isString(handler) ? handler.split('.')[0] : handler;
    },
    getHandlerFromString(app, route) {
        if (route['*']) {
            exports.Utils.methods.forEach(method => {
                if (!route[method]) {
                    route[method] = route['*'];
                }
            });
        }
        exports.Utils.methods.forEach(method => {
            if (route[method]) {
                route.config = route.config || {};
                route.config.pre = exports.Utils.getControllerPolicy(app, null, method, route.config.pre);
                if (typeof route[method] === 'string') {
                    route.config.pre = exports.Utils.getControllerPolicy(app, route[method], method, route.config.pre);
                    return route[method] = {
                        handler: exports.Utils.getControllerFromString(app, route[method]),
                        config: route.config
                    };
                }
                else if (route[method] instanceof Object && route[method].hasOwnProperty('handler')) {
                    route[method].config = route[method].config || route.config;
                    route[method].config.pre = route[method].config.pre || route.config.pre;
                    if (typeof route[method].handler === 'string') {
                        route.config.pre = exports.Utils.getControllerPolicy(app, route[method].handler, method, route.config.pre);
                        return route[method] = Object.assign({}, route[method], { handler: exports.Utils.getControllerFromString(app, route[method].handler) });
                    }
                    else {
                        return route[method] = Object.assign({}, route[method], { handler: route[method].handler });
                    }
                }
                else {
                    return route[method];
                }
            }
        });
    },
    buildRoutes(app, routes, toReturn = {}) {
        Object.keys(routes).forEach(p => {
            exports.Utils.splitRoute(app, p, routes[p]).forEach(({ path, route }) => {
                toReturn[path] = route;
            });
        });
        return exports.Utils.sortRoutes(toReturn, app.config.get('router.sortOrder'));
    },
    sortRoutes(routes, order) {
        const toReturn = new Map;
        const sorted = Object.keys(routes).sort(exports.Utils.createSpecificityComparator({ order: order }));
        sorted.forEach((r, i) => {
            toReturn.set(r, routes[r]);
        });
        return toReturn;
    },
    createSpecificityComparator: function (options) {
        options = options || {};
        let asc = false;
        if (options.order && options.order === 'asc') {
            asc = true;
        }
        const defaultRoute = options.default || '';
        const catchAllRoute = options.catchAllRoute || '*';
        return function specificityComparator(routeA, routeB) {
            routeA = (routeA || '').toLowerCase();
            routeB = (routeB || '').toLowerCase();
            if (routeA === defaultRoute
                || routeA === catchAllRoute) {
                return asc ? 1 : -1;
            }
            else if (routeB === defaultRoute
                || routeB === catchAllRoute) {
                return asc ? -1 : 1;
            }
            else if (/^\/$/.test(routeA) && (routeB !== defaultRoute && routeB !== catchAllRoute)) {
                return asc ? 1 : -1;
            }
            else {
                const slicedA = routeA.split('/');
                const slicedB = routeB.split('/');
                const joinedA = slicedA.join('');
                const joinedB = slicedB.join('');
                const depthA = exports.Utils.optionalParts(slicedA);
                const depthB = exports.Utils.optionalParts(slicedB);
                if (slicedA[1] > slicedB[1]) {
                    return asc ? 1 : -1;
                }
                if (slicedA[1] < slicedB[1]) {
                    return asc ? -1 : 1;
                }
                if (slicedA[1] === slicedB[1]) {
                    if (depthA > depthB) {
                        return asc ? 1 : -1;
                    }
                    if (depthA < depthB) {
                        return asc ? -1 : 1;
                    }
                    if (depthA === depthB) {
                        const weightA = exports.Utils.freeVariableWeight(joinedA);
                        const weightB = exports.Utils.freeVariableWeight(joinedB);
                        if (weightA > weightB) {
                            return asc ? -1 : 1;
                        }
                        if (weightA < weightB) {
                            return asc ? 1 : -1;
                        }
                        if (weightA === weightB) {
                            if (joinedA > joinedB) {
                                return asc ? 1 : -1;
                            }
                            if (joinedA < joinedB) {
                                return asc ? -1 : 1;
                            }
                        }
                    }
                }
            }
            return 0;
        };
    },
    freeVariableWeight: function (sliced) {
        const colMatches = sliced.match(/(:|\{)/gm);
        const optionalMatches = sliced.match(/(\?\})/gm);
        const col = colMatches ? colMatches.length : 0;
        const optional = optionalMatches ? optionalMatches.length : 0;
        return col - optional;
    },
    optionalParts: function (sliced) {
        let count = 0;
        sliced.forEach(slice => {
            if (!/\{.*\?\}$/.test(slice)) {
                count = count + 1;
            }
            else {
            }
        });
        return count;
    }
};
