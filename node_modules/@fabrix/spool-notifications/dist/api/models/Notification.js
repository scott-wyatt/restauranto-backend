"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@fabrix/fabrix/dist/common");
const spool_sequelize_1 = require("@fabrix/spool-sequelize");
const errors_1 = require("@fabrix/spool-sequelize/dist/errors");
const shortId = require("shortid");
const lodash_1 = require("lodash");
const queryDefaults_1 = require("../utils/queryDefaults");
const enums_1 = require("../../enums");
class NotificationResolver extends spool_sequelize_1.SequelizeResolver {
    findByIdDefault(id, options = {}) {
        options = this.app.services.SequelizeService.mergeOptionDefaults(queryDefaults_1.NotificationDefaults.default(this.app), options);
        return this.findById(id, options);
    }
    findByTokenDefault(token, options = {}) {
        options = this.app.services.SequelizeService.mergeOptionDefaults(queryDefaults_1.NotificationDefaults.default(this.app), options, {
            where: {
                token: token
            }
        });
        return this.findOne(options);
    }
    findOneDefault(options = {}) {
        options = this.app.services.SequelizeService.mergeOptionDefaults(queryDefaults_1.NotificationDefaults.default(this.app), options);
        return this.findOne(options);
    }
    findAllDefault(options = {}) {
        options = this.app.services.SequelizeService.mergeOptionDefaults(queryDefaults_1.NotificationDefaults.default(this.app), options);
        return this.findAll(options);
    }
    findAndCountDefault(options = {}) {
        options = this.app.services.SequelizeService.mergeOptionDefaults(queryDefaults_1.NotificationDefaults.default(this.app), options);
        return this.findAndCountAll(options);
    }
    createDefault(notification, options = {}) {
        options = this.app.services.SequelizeService.mergeOptionDefaults(queryDefaults_1.NotificationDefaults.default(this.app), options);
        return this.create(notification, options);
    }
    resolveByInstance(notification, options = {}) {
        return Promise.resolve(notification);
    }
    resolveById(notification, options = {}) {
        return this.findById(notification.id, options)
            .then(resNotification => {
            if (!resNotification && options.reject !== false) {
                throw new errors_1.ModelError('E_NOT_FOUND', `Notification ${notification.id} not found`);
            }
            return resNotification;
        });
    }
    resolveByToken(notification, options = {}) {
        return this.findOne(lodash_1.defaultsDeep({
            where: {
                token: notification.token
            }
        }, options))
            .then(resNotification => {
            if (!resNotification && options.reject !== false) {
                throw new errors_1.ModelError('E_NOT_FOUND', `Notification token ${notification.token} not found`);
            }
            return resNotification;
        });
    }
    resolveByNumber(notification, options = {}) {
        return this.findById(notification, options)
            .then(resNotification => {
            if (!resNotification && options.reject !== false) {
                throw new errors_1.ModelError('E_NOT_FOUND', `Notification ${notification.token} not found`);
            }
            return resNotification;
        });
    }
    resolveByString(notification, options = {}) {
        return this.findOne(lodash_1.defaultsDeep({
            where: {
                token: notification
            }
        }, options))
            .then(resNotification => {
            if (!resNotification && options.reject !== false) {
                throw new errors_1.ModelError('E_NOT_FOUND', `Notification ${notification} not found`);
            }
            return resNotification;
        });
    }
    resolve(notification, options = {}) {
        const resolvers = {
            'instance': notification instanceof this.sequelizeModel,
            'id': !!(notification && lodash_1.isObject(notification) && notification.id),
            'token': !!(notification && lodash_1.isObject(notification) && notification.token),
            'number': !!(notification && lodash_1.isNumber(notification)),
            'string': !!(notification && lodash_1.isString(notification))
        };
        const type = Object.keys(resolvers).find((key) => resolvers[key]);
        switch (type) {
            case 'instance': {
                return this.resolveByInstance(notification, options);
            }
            case 'id': {
                return this.resolveById(notification, options);
            }
            case 'token': {
                return this.resolveByToken(notification, options);
            }
            case 'number': {
                return this.resolveByNumber(notification, options);
            }
            case 'string': {
                return this.resolveByString(notification, options);
            }
            default: {
                const err = new Error(`Unable to resolve Notification ${notification}`);
                return Promise.reject(err);
            }
        }
    }
}
exports.NotificationResolver = NotificationResolver;
class Notification extends common_1.FabrixModel {
    static config(app, Sequelize) {
        return {
            options: {
                underscored: true,
                enums: {
                    PROTOCOLS: enums_1.PROTOCOLS
                },
                hooks: {
                    beforeCreate: (notification, options) => {
                        if (!notification.token) {
                            notification.token = `notification_${shortId.generate()}`;
                        }
                        if (!notification.subject) {
                            notification.subject = notification.type;
                        }
                        if (!notification.html) {
                            notification.html = app.services.RenderGenericService.renderSync(notification.text).document;
                        }
                    },
                    afterCreate: (notification, options) => {
                        return app.services.NotificationService.afterCreate(notification, options);
                    }
                },
                classMethods: {}
            }
        };
    }
    static schema(app, Sequelize) {
        return {
            token: {
                type: Sequelize.STRING,
                unique: true
            },
            protocol: {
                type: Sequelize.ENUM,
                values: lodash_1.values(enums_1.PROTOCOLS),
                defaultValue: app.config.get('generics.email_provider.config.protocol')
            },
            host: {
                type: Sequelize.STRING,
                defaultValue: app.config.get('generics.email_provider.config.host')
            },
            reply_to: {
                type: Sequelize.STRING,
                defaultValue: app.config.get('generics.email_provider.config.reply_to')
            },
            type: {
                type: Sequelize.STRING,
                allowNull: false
            },
            subject: {
                type: Sequelize.STRING
            },
            template_name: {
                type: Sequelize.STRING
            },
            template_content: {
                type: Sequelize.JSONB,
                defaultValue: {}
            },
            text: {
                type: Sequelize.TEXT,
                allowNull: false
            },
            html: {
                type: Sequelize.TEXT
            },
            total_opens: {
                type: Sequelize.INTEGER,
                defaultValue: 0
            },
            total_clicks: {
                type: Sequelize.INTEGER,
                defaultValue: 0
            },
            send_email: {
                type: Sequelize.BOOLEAN,
                defaultValue: true
            },
            sent: {
                type: Sequelize.BOOLEAN,
                defaultValue: false
            },
            sent_at: {
                type: Sequelize.DATE
            }
        };
    }
    static get resolver() {
        return NotificationResolver;
    }
    static associate(models) {
        models.Notification.belongsToMany(models.User, {
            as: 'users',
            through: {
                model: models.ItemNotification,
                unique: false,
                scope: {
                    model: 'user'
                }
            },
            foreignKey: 'notification_id',
            constraints: false
        });
    }
}
exports.Notification = Notification;
Notification.prototype.setSent = function () {
    this.sent = true;
    this.sent_at = new Date(Date.now());
    return this;
};
Notification.prototype.send = function (options = {}) {
    const sendType = this.template_name && this.template_name !== '' ? 'sendTemplate' : 'send';
    if (typeof this.send_email !== 'undefined' && this.send_email === false) {
        return Promise.resolve(this);
    }
    return this.resolveEmailUsers({ transaction: options.transaction || null })
        .then(emailUsers => {
        if (emailUsers && emailUsers.length > 0) {
            const _emailUsers = this.users.filter(user => user.email);
            const users = _emailUsers.map(user => {
                if (user) {
                    return {
                        email: user.email,
                        name: user.first_name || user.username || this.app.config.get('notifications.to.default_name')
                    };
                }
            });
            const message = {
                protocol: this.protocol,
                host: this.host,
                subject: this.subject,
                text: this.text,
                html: this.html,
                to: users,
                reply_to: this.reply_to || this.app.config.get('notifications.from.email'),
                from: {
                    email: this.app.config.get('notifications.from.email'),
                    name: this.app.config.get('notifications.from.name')
                },
                template_name: this.template_name,
                template_content: this.template_content
            };
            return this.app.services.EmailGenericService[sendType](message)
                .catch(err => {
                this.app.log.error(err);
                return null;
            });
        }
        else {
            return [];
        }
    })
        .then(emails => {
        if (emails.length > 0) {
            this.app.log.debug('EMAILS SENT', this.token, emails.length);
            return this.setSent(options).save({ transaction: options.transaction || null });
        }
        else {
            return this;
        }
    });
};
Notification.prototype.click = function (user, options = {}) {
    this.total_clicks++;
    return Promise.resolve(this);
};
Notification.prototype.open = function (user, options = {}) {
    this.total_opens++;
    if (!user) {
        return Promise.resolve(this);
    }
    else {
        return this.userOpened(user, options);
    }
};
Notification.prototype.userOpened = function (user, options = {}) {
    return this.app.models['ItemNotification'].update({ opened: true }, {
        where: {
            notification_id: this.id,
            model: 'user',
            model_id: user.id
        },
        transaction: options.transaction || null
    })
        .then(() => {
        return this;
    })
        .catch(err => {
        this.app.log.error(err);
        return this;
    });
};
Notification.prototype.resolveUsers = function (options = {}) {
    if (this.users
        && this.users.length > 0
        && this.users.every(u => u instanceof this.app.models['User'].instance)
        && options.reload !== true) {
        return Promise.resolve(this);
    }
    else {
        return this.getUsers({ transaction: options.transaction || null })
            .then(_users => {
            _users = _users || [];
            this.users = _users;
            this.setDataValue('users', _users);
            this.set('users', _users);
            return this;
        });
    }
};
Notification.prototype.resolveEmailUsers = function (options = {}) {
    let emailUsers = [];
    return this.resolveUsers({
        transaction: options.transaction || null,
        reload: options.reload || null
    })
        .then(() => {
        if (this.users && this.users.length > 0) {
            emailUsers = this.users.map(user => {
                let send = true;
                if (typeof user.email === 'undefined' || !user.email) {
                    send = false;
                }
                if (!user.preferences) {
                    user.preferences = {};
                }
                if (typeof user.preferences === 'string') {
                    try {
                        user.preferences = JSON.parse(user.preferences);
                    }
                    catch (err) {
                        this.app.log.error('Unable to parse user.preferences');
                        user.preferences = {};
                    }
                }
                if (user.preferences.email === false) {
                    send = false;
                }
                if (user.preferences.email === 'undefined') {
                    user.preferences.email = {};
                }
                if (typeof user.preferences.email !== 'undefined'
                    && user.preferences.email === false) {
                    send = false;
                }
                else if (typeof user.preferences.email !== 'undefined'
                    && user.preferences.email[this.type] === false) {
                    send = false;
                }
                return send === true;
            });
        }
        emailUsers = emailUsers.filter(n => n);
        return emailUsers;
    })
        .catch(err => {
        this.app.log.error(err);
        return emailUsers;
    });
};
